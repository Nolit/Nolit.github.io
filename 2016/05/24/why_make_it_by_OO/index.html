<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="author" content="John Doe">

  
  <meta name="description" content="title:「なぜオブジェクト指向で作るのか」を読んでみてオブジェクト指向を意識して設計してる時に、「一体何を抽象化してるんだ？」「そもそも抽象化とは何？」「オブジェクト指向って何？って聞かれて説明出来るのか」こんな思いからオブジェクト指向とはなにかっていう基礎の部分を学習してみる
歴史初めのOOP">
  
  

  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><nav>
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>
  <div id="content" class="inner"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title"></h1>
  

    <time datetime="2016-05-24T14:09:34.640Z">
  <span class="day">24</span><span class="month">May</span>
</time>
  </header>
  <div class="entry-content">
    
      <hr>
<h2 id="title-「なぜオブジェクト指向で作るのか」を読んでみて"><a href="#title-「なぜオブジェクト指向で作るのか」を読んでみて" class="headerlink" title="title:「なぜオブジェクト指向で作るのか」を読んでみて"></a>title:「なぜオブジェクト指向で作るのか」を読んでみて</h2><p>オブジェクト指向を意識して設計してる時に、「一体何を抽象化してるんだ？」「そもそも抽象化とは何？」「オブジェクト指向って何？って聞かれて説明出来るのか」<br>こんな思いから<strong>オブジェクト指向とはなにか</strong>っていう基礎の部分を学習してみる</p>
<h1 id="歴史"><a href="#歴史" class="headerlink" title="歴史"></a>歴史</h1><p>初めのOOPはシミュラ67という言語<br>クラス・継承・ポリモフィズムという仕組みを持っていた<br>この仕組みを取り入れたsmalltalkという言語がその後出た<br>OOP以前の構造化言語ではローカル変数よりも長いスコープが必要な場合、グローバル変数を使用するしかなく、<br>グローバル変数の値が異常だった場合、<strong>グローバル変数を参照することが出来る全てのサブルーチン</strong>から問題を切り分けるのが大変だった<br>また、サブルーチン単位でしか共通部品化出来なかった</p>
<hr>
<h1 id="OOPの三大要素"><a href="#OOPの三大要素" class="headerlink" title="OOPの三大要素"></a>OOPの三大要素</h1><p>OOPの三大要素はクラス・ポリモフィズム・継承</p>
<hr>
<h2 id="クラス"><a href="#クラス" class="headerlink" title="クラス"></a>クラス</h2><p>「まとめて」「隠して」「たくさん作る」</p>
<h3 id="まとめる"><a href="#まとめる" class="headerlink" title="まとめる"></a>まとめる</h3><ul>
<li>関連するサブルーチンとグローバル変数をクラスとしてまとめる</li>
<li>クラスという単位に分割して保守性が向上</li>
<li>クラス単位で分割することによって、サブルーチンが探しやすくなった</li>
</ul>
<h3 id="隠す"><a href="#隠す" class="headerlink" title="隠す"></a>隠す</h3><ul>
<li>メソッドやフィールドをクラス外から触れないようにする</li>
<li>問題発生時に<strong>外部からの操作が原因かもしれないという可能性を排除</strong>出来る</li>
</ul>
<h3 id="たくさん作る"><a href="#たくさん作る" class="headerlink" title="たくさん作る"></a>たくさん作る</h3><ul>
<li>インスタンスはそれぞれが状態を持っているのでクラスを利用する側で<strong>状態を管理しなくて良い</strong></li>
</ul>
<hr>
<h2 id="ポリモフィズム"><a href="#ポリモフィズム" class="headerlink" title="ポリモフィズム"></a>ポリモフィズム</h2><p><strong><em>共通メインルーチンを作るための仕組み</em></strong></p>
<ul>
<li><h4 id="共通サブルーチン"><a href="#共通サブルーチン" class="headerlink" title="共通サブルーチン"></a>共通サブルーチン</h4><p>呼び出される側のロジックを一つにまとめる<br>呼び出す側が増えてもサブルーチンを変更しなくて良い</p>
</li>
<li><h4 id="共通メインルーチン"><a href="#共通メインルーチン" class="headerlink" title="共通メインルーチン"></a>共通メインルーチン</h4><p><strong>呼び出す側のロジック</strong>を一つにまとめる<br>呼び出される側が増えてもメインルーチンを変更しなくて良い</p>
</li>
</ul>
<p>ポリモフィズムの実装は僕の知っている限り2種類</p>
<ol>
<li>親クラス・インターフェースを使う</li>
<li>ダックタイピング</li>
</ol>
<hr>
<h2 id="継承"><a href="#継承" class="headerlink" title="継承"></a>継承</h2><p>継承には２つの役割がある</p>
<ol>
<li>クラスの共通する定義を別のクラスにまとめること</li>
<li>親クラスに対してのポリモフィズムを認めること</li>
</ol>
<p>2はクラスの同一視について書いている<br>ポリモフィズムは共通メインルーチンを作るための仕組みと書いた<br>この共通メインルーチンというのが親クラスのメソッド群のこと<br>親クラスのメソッド群は子クラスで使えるので、無数に子クラスが存在していてもその子クラス達は親クラスとして扱える<br>これがクラスの同一視<br>つまり2のポリモフィズムを認めるとは、同一視した他の子クラスと同じように自分を扱っても良いよってこと<br><em>javaのような強い型付け言語だとコンパイル時にポリモフィズムを保障してくれる</em></p>
<hr>
<h1 id="進化したOOPの仕組み"><a href="#進化したOOPの仕組み" class="headerlink" title="進化したOOPの仕組み"></a>進化したOOPの仕組み</h1><p>javaやC#にはクラス・継承・ポリモフィズム以外にも進んだ機能がある</p>
<h2 id="パッケージ"><a href="#パッケージ" class="headerlink" title="パッケージ"></a>パッケージ</h2><p><strong><em>クラスをまとめる仕組み</em></strong><br>ディレクトリのように階層構造でクラスをまとめる<br>標準的な命名規則を決めることによって全世界で名前の重複を避けることが出来るので、クラスの再利用時に重複を気にしなくて良くなる</p>
<hr>
<h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p><strong><em>戻り値とは違う形式でメソッドから特別な値を返す仕組み</em></strong><br>例えば三つのメソッドがA-&gt;B-&gt;Cという関係になっていてCでエラーの可能性があるとする<br>もし例外という仕組みが無かった場合エラーコードを直接扱う事になるが、それだと面倒なことが二つある</p>
<ol>
<li>プログラム中にエラーコードの判定をしないといけないが、判定処理を忘れていた場合に気付けない</li>
<li>1.の判定がこの例だとBからAというように連鎖するので、呼び出しが深くなるにつれ面倒になっていく</li>
</ol>
<p>例外という仕組みはこの二つを解決してくれる<br>例外という仕組みでは特別なエラー(例外)を返すということをメソッドで宣言しないといけない<br>例外を宣言したメソッドを呼び出す場合、例外を処理するロジックを書かないと実行時又はコンパイル時にエラーになる<br>これで1は解決<br>そして例外という仕組みでは自身でエラー処理をしたくない場合、呼び出し元にエラー処理を任せることが出来る<br>これで2も解決<br>まとめると例外という仕組みは、重複したエラー判定を一か所に出来るし、例外処理を忘れた場合はコンパイラや実行環境が教えてくれるという便利な仕組みである</p>
<hr>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article></div>
  <footer id="footer" class="inner"><div class="social alignright">
  
  
  
  
  <a class="rss" href="/atom.xml" title="RSS">RSS</a>
</div>
<p>
  
  &copy; 2016 John Doe
  
</p>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="phasebeam">
  <canvas></canvas>
  <canvas></canvas>
  <canvas></canvas>
</div>
<script src="/js/phasebeam.js"></script>
</body>
</html>